# Convert ARGB8888 bitmaps to C arrays

## Installation

Install with `pip` from the terminal:

```
pip install .
```

## Usage

The package provides console scripts for converting bitmaps:

- Convert bitmap data to C array:
  ```
  argb8888_to_c [-h] -i INPUT_FILE [-o EXTRA_FILE]
  ```

- Convert bitmap data to C array with 4-byte aligned pixel array:
  ```
  argb8888_to_c_aligned [-h] -i INPUT_FILE [-o OUTPUT FILE]
  ```

## Implementation details

When converting a bitmap to a C array, some applications require the [pixel array](https://en.wikipedia.org/wiki/BMP_file_format#Pixel_storage) to have a specific [memory alignment](https://www.songho.ca/misc/alignment/dataalign.html).
For example, the [STM32CubeF7 MCU Firmware Package](https://github.com/STMicroelectronics/STM32CubeF7) requires ARGB8888-formatted pixel arrays to be 4-byte aligned.

However, for ARGB8888 the default offset of the pixel array is 70. 
Therefore, even if the start of the overall bitmap data is 4-byte aligned in memory, the start of the pixel array is not.
When converting the bitmap file to a C array using standard tools (e.g., [Bin2C](https://www.segger.com/free-utilities/bin2c/)), the resulting pixel array is therefore not properly aligned.

Packag `bmp_argb8888_to_c` solves this problem by adding an additional gap of 2 bytes between the [DIB header](https://en.wikipedia.org/wiki/BMP_file_format#DIB_header_(bitmap_information_header)) and the pixel array when converting the bitmap.


## Example

The following example shows the resulting C array of a 5x15 pixel bitmap containing 5x5 pixels of blue (FF0000AA), 5x5 pixels of green (FF00BB00) and 5x5 pixels of red (FFCC0000).
With the help of an additional gap of 2 bytes after the DIB header, the resulting pixel array is 4-byte aligned.

```
#ifndef INCLUDE_TEST_BITMAP_H_
#define INCLUDE_TEST_BITMAP_H_

const unsigned char TEST_BITMAP[372UL + 1] __attribute__ ((aligned (4)))
{
  // BITMAP FILE HEADER
  0x42, 0x4D, // SIGNATURE
  0x74, 0x01, 0x00, 0x00, // FILE SIZE
  0x00, 0x00, 0x00, 0x00, // RESERVED
  0x48, 0x00, 0x00, 0x00, // PIXEL ARRAY OFFSET

  // DIB HEADER (BITMAPV3INFOHEADER)
  0x38, 0x00, 0x00, 0x00, // HEADER SIZE
  0x05, 0x00, 0x00, 0x00, // IMAGE WIDTH
  0x0F, 0x00, 0x00, 0x00, // IMAGE HEIGHT
  0x01, 0x00, // NUMBER OF COLOR PLANES
  0x20, 0x00, // NUMBER OF BITS PER PIXEL
  0x03, 0x00, 0x00, 0x00, // COMPRESSION METHOD
  0x2C, 0x01, 0x00, 0x00, // SIZE OF THE RAW BITMAP DATA
  0xC3, 0x0E, 0x00, 0x00, // HORIZONTAL RESOLUTION OF THE IMAGE
  0xC3, 0x0E, 0x00, 0x00, // VERTICAL RESOLUTION OF THE IMAGE
  0x00, 0x00, 0x00, 0x00, // NUMBER OF COLORS IN THE COLOR PALETTE
  0x00, 0x00, 0x00, 0x00, // NUMBER OF IMPORTANT COLORS USED
  0x00, 0x00, // UNITS FOR THE HORIZONTAL AND VERTICAL RESOLUTIONS
  0xFF, 0x00, // PADDING
  0x00, 0xFF, // DIRECTION IN WHICH THE BITS FILL THE BITMAP
  0x00, 0x00, // HALFTONING ALGORITHM
  0xFF, 0x00, 0x00, 0x00, // HALFTONING PARAMETER 1
  0x00, 0x00, 0x00, 0xFF, // HALFTONING PARAMETER 2

  0x00, 0x00, // GAP

  // PIXEL ARRAY
  0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF,
  0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF,
  0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF,
  0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF,
  0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF,
  0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF,
  0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF,
  0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF, 0x00, 0x00, 0xCC, 0xFF,
  0x00, 0x00, 0xCC, 0xFF, 0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF,
  0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF,
  0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF,
  0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF,
  0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF,
  0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF,
  0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF,
  0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF,
  0x00, 0xBB, 0x00, 0xFF, 0x00, 0xBB, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF,
  0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF,
  0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF,
  0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF,
  0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF,
  0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF,
  0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF,
  0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF,
  0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF, 0xAA, 0x00, 0x00, 0xFF,

  0x00 // EOF
};

#endif // INCLUDE_TEST_BITMAP_H_
```